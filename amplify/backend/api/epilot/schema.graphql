# --------------------
# Enums
# --------------------

enum GuessDirection {
  UP
  DOWN
}

enum GuessOutcome {
  WIN
  LOSS
}

enum GuessStatus {
  PENDING
  SETTLED
  FAILED
}

# --------------------
# Guess Model
# --------------------

type Guess
  @model
  @auth(
    rules: [
      {
        allow: owner
        ownerField: "owner"
        identityClaim: "sub"
        provider: userPools
        operations: [create, read, update, delete]
      }
      # Settlement Lambda uses API key to update guesses
      { allow: public, provider: apiKey, operations: [read, update] }
    ]
  ) {
  id: ID!
  owner: String
    @index(
      name: "guessesByOwnerCreatedAt"
      queryField: "guessesByOwner"
      sortKeyFields: ["createdAt"]
    )
    @auth(rules: [
      { allow: owner, identityClaim: "sub", operations: [read, delete] },
      { allow: public, provider: apiKey, operations: [read] }
    ])

  # Timestamps
  createdAt: AWSDateTime! # When guess was placed (used for start price resolution)
  settleAt: AWSDateTime! # Target settlement time (createdAt + 60s)

  # User's prediction
  direction: GuessDirection! # What the user predicted (UP or DOWN)

  # Price snapshot references (resolved at settlement)
  startPriceSnapshotId: ID # Nullable until settlement
  endPriceSnapshotId: ID # Nullable until settlement

  # Denormalized prices for query convenience (populated at settlement)
  startPrice: Float # From startPriceSnapshot.priceUsd
  endPrice: Float # From endPriceSnapshot.priceUsd

  # Outcome
  status: GuessStatus!
  result: GuessDirection # Actual price movement (UP/DOWN) - nullable until settled
  outcome: GuessOutcome # WIN/LOSS - nullable until settled
}

# --------------------
# PriceSnapshot Model
# --------------------

type PriceSnapshot
  @model
  @auth(
    rules: [
      { allow: private, provider: userPools, operations: [read] }
      { allow: public, provider: apiKey, operations: [create, read, delete] }
    ]
  ) {
  id: ID!
  pk: String!
    @index(
      name: "byPkCapturedAt"
      queryField: "priceSnapshotsByPk"
      sortKeyFields: ["capturedAt"]
    )
    @index(
      name: "byPkSourceUpdatedAt"
      queryField: "priceSnapshotsBySourceUpdatedAt"
      sortKeyFields: ["sourceUpdatedAt"]
    )
  capturedAt: AWSDateTime!
  sourceUpdatedAt: AWSDateTime
  priceUsd: Float!
  source: String
}

# --------------------
# UserState Model
# --------------------

type UserState
  @model
  @auth(
    rules: [
      {
        allow: owner
        ownerField: "owner"
        provider: userPools
        operations: [create, read, update, delete]
      }
      # apiKey needed for PostConfirmation Lambda to create UserState
      # and for settlement Lambda to update score
      { allow: public, provider: apiKey, operations: [create, update] }
    ]
  ) {
  id: ID!
  owner: String!
    @auth(
      rules: [
        { allow: owner, operations: [read, delete] }
        # apiKey needs to set owner field during create (PostConfirmation Lambda)
        { allow: public, provider: apiKey, operations: [create] }
      ]
    )
  email: AWSEmail!
  username: String!
  score: Int!
  streak: Int!
  lastUpdatedAt: AWSDateTime!
}
